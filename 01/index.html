
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Знайомство з Kotlin та базовим синтаксисом</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="UA-52746336-1"
                  id="your-first-pwapp"
                  title="Знайомство з Kotlin та базовим синтаксисом"
                  environment="web"
                  feedback-link="https://github.com/googlecodelabs/your-first-pwapp/issues">
    
      <google-codelab-step label="Загальна інформація" duration="0">
        <p>Kotlin - <strong>статично типізована</strong>, об&#39;єктно-орієнтована мова програмування (з підтримкою процедурного програмування), що працює поверх Java Virtual Machine і розробляється компанією JetBrains. Також компілюється в JavaScript і у виконуваний код низки платформ через інфраструктуру LLVM. Мова названа на честь острова Котлін у Фінській затоці.</p>
<p>Основні можливості та переваги Kotlin:</p>
<ul>
<li>компілюється в байткод JVM або в JavaScript</li>
<li>програми можуть використовувати всі наявні Java-фреймворки та бібліотеки. Kotlin можна інтегрувати з Maven, Gradle та іншими системами збірки проєкту</li>
<li>мова проста для вивчення</li>
<li>вихідний код відкритий</li>
<li>мова null-безпечна</li>
</ul>
<p>Оскільки Kotlin був спочатку спроєктова як JVM-мова, повністю сумісна з Java і навпаки, ви без зусиль можете успадковуватися від існуючих Java-класів, звертатися до них і застосовувати Java-анотації до ваших Kotlin-класів і методів. Перш за все, IntelliJ компілює код Kotlin, використовуючи компілятор kotlinc-jvm. Це означає, що IntelliJ транслює код на Kotlin у байт-код, мову, якою &#34;розмовляє&#34; JVM.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Базовий синтаксис" duration="0">
        <p>Створимо новий Kotlin-файл та додамо наступний код</p>
<p><code>Main.kt</code></p>
<pre><code>package ua.opnu.kotlin.tst

fun main() {
    println(&#34;Hello, world!&#34;)
}</code></pre>
<p>Перш за все, потрібно розібратися з першим рядком</p>
<pre><code>package ua.opnu.kotlin.tst</code></pre>
<p>Як і в Java, у мові Kotlin файли та класи об&#39;єднуються в пакети. Функціональність пакетів в обох мовах ідентична, за винятком того, що в Kotlin не обов&#39;язково (але вкрай бажано), щоб пакети повторювали структуру директорій на диску.</p>
<p>Як і в Java, для запуску проекту нам необхідно створити точку входу - метод <code>main()</code>.</p>
<p>У Kotlin функція <code>main()</code> має дві можливі сигнатури</p>
<pre><code>package example

// Перша сигнатура
fun main(args: Array&lt;String&gt;) {
    println(&#34;Hello, Kotlin!&#34;)
}

// Друга сигнатура
fun main() {
    println(&#34;Hello, Kotlin!&#34;)
}</code></pre>
<p>Перше, що ми можемо помітити, - ключове слово <code>fun</code>, яким у Kotlin позначаються функції.</p>
<p>На відміну від Java, в якій використовується термін метод, в Kotlin використовується термін функція. Це пов&#39;язано з тим, що згідно з ідеологією мови Java, весь виконуваний код знаходиться всередині класів. Таким чином, у Java немає функцій поза об&#39;єктом того чи іншого класу (питання статичних функцій залишимо осторонь).</p>
<p>У мові Kotlin підтримується механізм функцій верхнього рівня (top-level functions).</p>
<aside class="warning"><p>Поняття &#34;верхнього рівня&#34; (top-level) не варто плутати з поняттям &#34;вищого порядку&#34; (higher-order)</p>
</aside>
<p>Функції верхнього рівня - це функції, які визначаються у файлі поза іншими функціями, об&#39;єктами, класами або інтерфейсами, самі по собі, просто всередині пакета.</p>
<p>Але тут криється один нюанс - мова Kotlin має бути сумісною з Java і виконується всередині JVM. Тому &#34;під капотом&#34; замість функції верхнього рівня буде створено клас зі статичним методом.</p>
<p>Створимо файл <code>MyFile.kt</code> і всередині нього визначимо функцію <code>myFunc()</code>. Код мовою Kotlin матиме такий вигляд</p>
<pre><code>package example

fun myFunc() {
    println(&#34;Hello!&#34;)
}</code></pre>
<p>Тепер виберемо пункт меню <code>Tools->Kotlin->Show Kotlin Bytecode</code> і у вікні, що відкрилося праворуч, натиснемо на кнопку <code>Decompile</code>, після чого ми побачимо java-код, який буде ідентичний коду на Kotlin з погляду байткоду</p>
<pre><code>public final class MyFileKt {
   public static final void myFunc() {
      String var0 = &#34;Hello!&#34;;
      boolean var1 = false;
      System.out.println(var0);
   }
}</code></pre>
<aside class="warning"><p>Важливо розуміти, що багато &#34;фішок&#34; мови Kotlin існують лише на рівні вихідного коду, для зручності розробника.</p>
</aside>
<p>Продовжуємо розбирати вихідний код стартового проєкту. Рядок</p>
<pre><code>fun main(args: Array&lt;String&gt;) {</code></pre>
<p>говорить нам про те, що в Kotlin використовується <strong>Pascal notation</strong>, тобто оголошення виду <code>name: type</code>. Аргументи відокремлюються один від одного комою.</p>
<p>Масиви в Kotlin моделюються узагальненим класом <code>Array<T></code>. Більш детально ми розглянемо масиви пізніше.</p>
<p>Далі, розглянемо рядок</p>
<pre><code>println(&#34;Hello, Kotlin!&#34;)</code></pre>
<p>Зверніть увагу, що для виклику функції <code>println()</code> ми не підключали жодних бібліотек.</p>
<p>Класи та утиліти Kotlin містяться всередині <strong>стандартної бібліотеки Kotlin (Kotlin Standard Library)</strong>. Вона містить ключові компоненти мови Kotlin.</p>
<p>У кожен kotlin-файл за замовчуванням імпортуються такі пакети, які входять до стандартної бібліотеки Kotlin:</p>
<ul>
<li><code>kotlin.*</code></li>
<li><code>kotlin.annotation.*</code></li>
<li><code>kotlin.collections.*</code></li>
<li><code>kotlin.comparisons.*</code></li>
<li><code>kotlin.io.*</code></li>
<li><code>kotlin.ranges.*</code></li>
<li><code>kotlin.sequences.*</code></li>
<li><code>kotlin.text.*</code></li>
</ul>
<p>Також, якщо цільовою платформою Kotlin є JVM (як у нашому випадку), то додатково імпортуються такі пакети:</p>
<ul>
<li><code>java.lang.*</code></li>
<li><code>kotlin.jvm.*</code></li>
</ul>
<p>Таким чином, ми можемо використовувати велику кількість готових класів і функцій без необхідності їх явно імпортувати.</p>
<p>Ну й останнє, на що варто звернути увагу - немає потреби ставити <code>;</code> після кожної інструкції (є два винятки, але поки що не будемо їх торкатися).</p>


      </google-codelab-step>
    
      <google-codelab-step label="Типи даних" duration="0">
        

      </google-codelab-step>
    
      <google-codelab-step label="Висновки" duration="0">
        

      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
